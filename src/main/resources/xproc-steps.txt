prefix p = "{http://www.w3.org/ns/xproc}"
prefix cx = "{http://xmlcalabash.com/ns/extensions}"
prefix xc = "com.xmlcalabash.steps."
prefix xf = "com.xmlcalabash.functions."

function p:system-property     has implementation xf:SystemProperty
function p:document-properties has implementation xf:DocumentProperties
function cx:cwd                has implementation xf:Cwd

step p:error has implementation xc:Error
  option code as QName
  option code-prefix? as NCName
  option code-namespace? as anyURI
  option message? as string

step p:identity has implementation xc:Identity
  input source*
  output result*

step p:parameters has implementation xc:Parameters
  output result
  option parameters

step p:wrap-sequence has implementation xc:WrapSequence
  input source*
  output result*
  option wrapper as QName
  option wrapper-prefix? as NCName
  option wrapper-namespace? as anyURI
  option group-adjacent? as XPathExpression

step p:xslt has implementation xc:Xslt
  primary input source*
  input stylesheet
  primary output result
  output secondary*
  option parameters
  option initial-mode? as QName
  option template-name? as QName
  option output-base-uri? as anyURI
  option version?

// ============================================================

step cx:peephole has implementation xc:Peephole
  input source
  output result

step cx:option-value has implementation xc:OptionValue
  output result
  option option

/*
step p:add-attribute
  input source
  output result
  option match as XSLTMatchPattern
  option attribute-name as QName
  option attribute-prefix? as NCName
  option attribute-namespace? as anyURI
  option attribute-value

step p:add-xml-base
  input source
  output result
  option all? as boolean = 'false'
  option relative? as boolean = 'true'

step p:compare
  primary input source
  input alternate
  output result
  option fail-if-not-equal? as boolean = 'false'

step p:count
  input source*
  output result
  option limit? as integer = "0"

step p:delete
  input source
  output result
  option match as XSLTMatchPattern

step p:directory-list
  output result
  option path as anyURI
  option include-filter? as RegularExpression
  option exclude-filter? as RegularExpression

step p:escape-markup
  input source
  output result
  option cdata-section-elements?
  option doctype-public?
  option doctype-system? as anyURI
  option escape-uri-attributes? as boolean = 'false'
  option include-content-type? as boolean = 'true'
  option indent? as boolean = 'false'
  option media-type?
  option method? as QName = 'xml'
  option omit-xml-declaration? as boolean = 'true'
  option standalone? of (true|false|omit) = 'omit'
  option undeclare-prefixes? as boolean
  option version? as string = '1.0'

step p:filter
  input source
  output result*
  option select as XPathExpression

step p:http-request
  input source
  output result
  option byte-order-mark? as boolean
  option cdata-section-elements?
  option doctype-public?
  option doctype-system? as anyURI
  option encoding?
  option escape-uri-attributes? as boolean = 'false'
  option include-content-type? as boolean = 'true'
  option indent? as boolean = 'false'
  option media-type?
  option method? as QName = 'xml'
  option normalization-form? as string = 'none'
  option omit-xml-declaration? as boolean = 'true'
  option standalone? of (true|false|omit) = 'omit'
  option undeclare-prefixes? as boolean
  option version? as string = '1.0'

step p:insert
  primary input source
  input insertion*
  output result
  option match? as XSLTMatchPattern = '/*'
  option position of (first-child|last-child|before|after)

step p:label-elements
  input source
  output result
  option attribute? as QName = 'xml:id'
  option attribute-prefix? as NCName
  option attribute-namespace? as anyURI
  option label? as XPathExpression = 'concat("_",$p:index)'
  option match? as XSLTMatchPattern = '*'
  option replace? as boolean = 'true'

step p:load
  output result
  option href as anyURI
  option dtd-validate? as boolean = 'false'

step p:make-absolute-uris
  input source
  output result
  option match as XSLTMatchPattern
  option base-uri? as anyURI

step p:namespace-rename
  input source
  output result
  option from? as anyURI
  option to? as anyURI
  option apply-to? of (all|elements|attributes) = 'all'

step p:pack
  primary input source*
  input alternate*
  output result*
  option wrapper as QName
  option wrapper-prefix? as NCName
  option wrapper-namespace? as anyURI

step p:rename
  input source
  output result
  option match as XSLTMatchPattern
  option new-name as QName
  option new-prefix? as NCName
  option new-namespace? as anyURI

step p:replace
  primary input source
  input replacement
  output result
  option match as XSLTMatchPattern

step p:set-attributes
  primary input source
  input attributes
  output result
  option match as XSLTMatchPattern

step p:sink
  input source*

step p:split-sequence
  input source*
  primary output matched*
  output not-matched*
  option initial-only? as boolean = 'false'
  option test as XPathExpression

step p:store
  input source
  output result
  option href as anyURI
  option byte-order-mark? as boolean
  option cdata-section-elements?
  option doctype-public?
  option doctype-system? as anyURI
  option encoding?
  option escape-uri-attributes? as boolean = 'false'
  option include-content-type? as boolean = 'true'
  option indent? as boolean = 'false'
  option media-type?
  option method? as QName = 'xml'
  option normalization-form? as NormalizationForm = 'none'
  option omit-xml-declaration? as boolean = 'true'
  option standalone? of (true|false|omit) = 'omit'
  option undeclare-prefixes? as boolean
  option version? as string = '1.0'

step p:string-replace
  input source
  output result
  option match as XSLTMatchPattern
  option replace as XPathExpression

step p:unescape-markup
  input source
  output result
  option namespace? as anyURI
  option content-type? as string = 'application/xml'
  option encoding?
  option charset?

step p:unwrap
  input source
  output result
  option match as XSLTMatchPattern

step p:wrap
  input source
  output result
  option wrapper as QName
  option wrapper-prefix? as NCName
  option wrapper-namespace? as anyURI
  option match as XSLTMatchPattern
  option group-adjacent? as XPathExpression

step p:wrap-sequence
  input source*
  output result*
  option wrapper as QName
  option wrapper-prefix? as NCName
  option wrapper-namespace? as anyURI
  option group-adjacent? as XPathExpression

step p:xinclude
  input source
  output result
  option fixup-xml-base? as boolean = 'false'
  option fixup-xml-lang? as boolean = 'false'

step p:exec
  primary input source*
  primary output result
  output errors
  output exit-status
  option command
  option args? as string = ''
  option cwd?
  option source-is-xml? as boolean = 'true'
  option result-is-xml? as boolean = 'true'
  option wrap-result-lines? as boolean = 'false'
  option errors-is-xml? as boolean = 'false'
  option wrap-error-lines? as boolean = 'false'
  option path-separator?
  option failure-threshold? as integer
  option arg-separator? as string = ' '
  option byte-order-mark? as boolean
  option cdata-section-elements?
  option doctype-public?
  option doctype-system? as anyURI
  option encoding?
  option escape-uri-attributes? as boolean = 'false'
  option include-content-type? as boolean = 'true'
  option indent? as boolean = 'false'
  option media-type?
  option method? as QName = 'xml'
  option normalization-form? as NormalizationForm = 'none'
  option omit-xml-declaration? as boolean = 'true'
  option standalone? of (true|false|omit) = 'omit'
  option undeclare-prefixes? as boolean
  option version? as string = '1.0'

step p:hash
  primary input source
  output result
  option value
  option algorithm as QName
  option match as XSLTMatchPattern
  option version?

step p:uuid
  primary input source
  output result
  option match as XSLTMatchPattern
  option version? as integer

step p:validate-with-relax-ng
  primary input source
  input schema
  output result
  option dtd-attribute-values? as boolean = 'false'
  option dtd-id-idref-warnings? as boolean = 'false'
  option assert-valid? as boolean = 'true'

step p:validate-with-schematron
  primary input source
  input schema
  primary output result
  output report*
  option phase? as string = '#ALL'
  option assert-valid? as boolean = 'true'

step p:validate-with-xml-schema
  primary input source
  input schema*
  output result
  option use-location-hints? as boolean = 'false'
  option try-namespaces? as boolean = 'false'
  option assert-valid? as boolean = 'true'
  option mode? of (strict|lax) = 'strict'

step p:www-form-urldecode
  output result
  option value

step p:www-form-urlencode
  primary input source
  output result
  option match as XSLTMatchPattern

step p:xquery
  primary input source*
  input query
  output result*

step p:xsl-formatter
  input source
  output result
  option href as anyURI
  option content-type?
*/
